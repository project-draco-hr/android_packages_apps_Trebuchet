{
  Set<String> savedIds=new HashSet<String>();
  for (int i=0; i < in.key.length; i++) {
    Key key=in.key[i];
    if (key.type == Key.SCREEN) {
      savedIds.add(keyToBackupKey(key));
    }
  }
  if (DEBUG)   Log.d(TAG,"screens savedIds.size()=" + savedIds.size());
  ContentResolver cr=getContentResolver();
  String where=ChangeLogColumns.MODIFIED + " > ?";
  String[] args={Long.toString(in.t)};
  String updateOrder=ChangeLogColumns.MODIFIED;
  Cursor updated=cr.query(WorkspaceScreens.CONTENT_URI,SCREEN_PROJECTION,where,args,updateOrder);
  updated.moveToPosition(-1);
  if (DEBUG)   Log.d(TAG,"screens updated.getCount()=" + updated.getCount());
  try {
    while (updated.moveToNext()) {
      final long id=updated.getLong(ID_INDEX);
      Key key=getKey(Key.SCREEN,id);
      byte[] blob=packScreen(updated);
      String backupKey=keyToBackupKey(key);
      data.writeEntityHeader(backupKey,blob.length);
      data.writeEntityData(blob,blob.length);
      out.rows++;
      out.bytes+=blob.length;
      Log.v(TAG,"saving screen " + backupKey + ": "+ id+ "/"+ blob.length);
      if (DEBUG)       Log.d(TAG,"wrote " + Base64.encodeToString(blob,0,blob.length,Base64.NO_WRAP));
      savedIds.add(backupKey);
    }
  }
  finally {
    updated.close();
  }
  if (DEBUG)   Log.d(TAG,"screen savedIds.size()=" + savedIds.size());
  String idOrder=BaseColumns._ID;
  Cursor idCursor=cr.query(WorkspaceScreens.CONTENT_URI,ID_ONLY_PROJECTION,null,null,idOrder);
  idCursor.moveToPosition(-1);
  Set<String> currentIds=new HashSet<String>(idCursor.getCount());
  try {
    while (idCursor.moveToNext()) {
      Key key=getKey(Key.SCREEN,idCursor.getLong(ID_INDEX));
      currentIds.add(keyToBackupKey(key));
      keys.add(key);
    }
  }
  finally {
    idCursor.close();
  }
  if (DEBUG)   Log.d(TAG,"screen currentIds.size()=" + currentIds.size());
  savedIds.removeAll(currentIds);
  for (  String deleted : savedIds) {
    Log.v(TAG,"dropping screen " + deleted);
    data.writeEntityHeader(deleted,-1);
    out.rows++;
  }
}
