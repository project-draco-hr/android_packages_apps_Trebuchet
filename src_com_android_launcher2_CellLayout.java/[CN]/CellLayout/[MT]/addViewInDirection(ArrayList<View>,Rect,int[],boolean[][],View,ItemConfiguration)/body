{
  boolean found=false;
  int childCount=mShortcutsAndWidgets.getChildCount();
  Rect r0=new Rect(boundingRect);
  Rect r1=new Rect();
  int deltaX=0;
  int deltaY=0;
  if (direction[1] < 0) {
    r0.set(r0.left,r0.top - 1,r0.right,r0.bottom - 1);
    deltaY=-1;
  }
 else   if (direction[1] > 0) {
    r0.set(r0.left,r0.top + 1,r0.right,r0.bottom + 1);
    deltaY=1;
  }
 else   if (direction[0] < 0) {
    r0.set(r0.left - 1,r0.top,r0.right - 1,r0.bottom);
    deltaX=-1;
  }
 else   if (direction[0] > 0) {
    r0.set(r0.left + 1,r0.top,r0.right + 1,r0.bottom);
    deltaX=1;
  }
  for (int i=0; i < childCount; i++) {
    View child=mShortcutsAndWidgets.getChildAt(i);
    if (views.contains(child) || child == dragView)     continue;
    CellAndSpan c=currentState.map.get(child);
    LayoutParams lp=(LayoutParams)child.getLayoutParams();
    r1.set(c.x,c.y,c.x + c.spanX,c.y + c.spanY);
    if (Rect.intersects(r0,r1)) {
      if (!lp.canReorder) {
        return false;
      }
      if ((direction[0] < 0 && c.x == r0.left) || (direction[0] > 0 && c.x == r0.right - 1) || (direction[1] < 0 && c.y == r0.top)|| (direction[1] > 0 && c.y == r0.bottom - 1)) {
        boolean pushed=false;
        for (int x=c.x; x < c.x + c.spanX; x++) {
          for (int y=c.y; y < c.y + c.spanY; y++) {
            if (occupied[x - deltaX][y - deltaY]) {
              pushed=true;
              break;
            }
            if (pushed)             break;
          }
        }
        if (pushed) {
          views.add(child);
          boundingRect.union(c.x,c.y,c.x + c.spanX,c.y + c.spanY);
          found=true;
        }
      }
    }
  }
  return found;
}
