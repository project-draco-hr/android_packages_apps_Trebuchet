{
  super(context,attrs,defStyle);
  setWillNotDraw(false);
  TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.CellLayout,defStyle,0);
  mOriginalCellWidth=mCellWidth=a.getDimensionPixelSize(R.styleable.CellLayout_cellWidth,10);
  mOriginalCellHeight=mCellHeight=a.getDimensionPixelSize(R.styleable.CellLayout_cellHeight,10);
  mWidthGap=mOriginalWidthGap=a.getDimensionPixelSize(R.styleable.CellLayout_widthGap,0);
  mHeightGap=mOriginalHeightGap=a.getDimensionPixelSize(R.styleable.CellLayout_heightGap,0);
  mMaxGap=a.getDimensionPixelSize(R.styleable.CellLayout_maxGap,0);
  mCountX=LauncherModel.getCellCountX();
  mCountY=LauncherModel.getCellCountY();
  mOccupied=new boolean[mCountX][mCountY];
  a.recycle();
  setAlwaysDrawnWithCacheEnabled(false);
  final Resources res=getResources();
  mNormalBackground=res.getDrawable(R.drawable.homescreen_blue_normal_holo);
  mActiveGlowBackground=res.getDrawable(R.drawable.homescreen_blue_strong_holo);
  mOverScrollLeft=res.getDrawable(R.drawable.overscroll_glow_left);
  mOverScrollRight=res.getDrawable(R.drawable.overscroll_glow_right);
  mForegroundPadding=res.getDimensionPixelSize(R.dimen.workspace_overscroll_drawable_padding);
  mNormalBackground.setFilterBitmap(true);
  mActiveGlowBackground.setFilterBitmap(true);
  mBubbleScalePercent=res.getInteger(R.integer.app_icon_scale_percent);
  mBubbleHotseatScalePercent=res.getInteger(R.integer.app_icon_hotseat_scale_percent);
  mCrosshairsDrawable=res.getDrawable(R.drawable.gardening_crosshairs);
  mEaseOutInterpolator=new DecelerateInterpolator(2.5f);
  int animDuration=res.getInteger(R.integer.config_crosshairsFadeInTime);
  mCrosshairsAnimator=new InterruptibleInOutAnimator(animDuration,0.0f,1.0f);
  mCrosshairsAnimator.getAnimator().addUpdateListener(new AnimatorUpdateListener(){
    public void onAnimationUpdate(    ValueAnimator animation){
      mCrosshairsVisibility=((Float)animation.getAnimatedValue()).floatValue();
      invalidate();
    }
  }
);
  mCrosshairsAnimator.getAnimator().setInterpolator(mEaseOutInterpolator);
  mDragCell[0]=mDragCell[1]=-1;
  for (int i=0; i < mDragOutlines.length; i++) {
    mDragOutlines[i]=new Point(-1,-1);
  }
  final int duration=res.getInteger(R.integer.config_dragOutlineFadeTime);
  final float fromAlphaValue=0;
  final float toAlphaValue=(float)res.getInteger(R.integer.config_dragOutlineMaxAlpha);
  Arrays.fill(mDragOutlineAlphas,fromAlphaValue);
  for (int i=0; i < mDragOutlineAnims.length; i++) {
    final InterruptibleInOutAnimator anim=new InterruptibleInOutAnimator(duration,fromAlphaValue,toAlphaValue);
    anim.getAnimator().setInterpolator(mEaseOutInterpolator);
    final int thisIndex=i;
    anim.getAnimator().addUpdateListener(new AnimatorUpdateListener(){
      public void onAnimationUpdate(      ValueAnimator animation){
        final Bitmap outline=(Bitmap)anim.getTag();
        if (outline == null) {
          if (false) {
            Object val=animation.getAnimatedValue();
            Log.d(TAG,"anim " + thisIndex + " update: "+ val+ ", isStopped "+ anim.isStopped());
          }
          animation.cancel();
        }
 else {
          mDragOutlineAlphas[thisIndex]=(Float)animation.getAnimatedValue();
          final int left=mDragOutlines[thisIndex].x;
          final int top=mDragOutlines[thisIndex].y;
          CellLayout.this.invalidate(left,top,left + outline.getWidth(),top + outline.getHeight());
        }
      }
    }
);
    anim.getAnimator().addListener(new AnimatorListenerAdapter(){
      @Override public void onAnimationEnd(      Animator animation){
        if ((Float)((ValueAnimator)animation).getAnimatedValue() == 0f) {
          anim.setTag(null);
        }
      }
    }
);
    mDragOutlineAnims[i]=anim;
  }
  mBackgroundRect=new Rect();
  mForegroundRect=new Rect();
  mChildren=new CellLayoutChildren(context);
  mChildren.setCellDimensions(mCellWidth,mCellHeight,mWidthGap,mHeightGap);
  addView(mChildren);
}
