{
  final String name=getObjectName(o);
  final String packageName=getObjectPackage(o);
synchronized (sInvalidPackages) {
    boolean packageValid=!sInvalidPackages.contains(packageName);
    if (!packageValid) {
      return null;
    }
  }
synchronized (mLoadedPreviews) {
    if (mLoadedPreviews.containsKey(name)) {
      WeakReference<Bitmap> bitmapReference=mLoadedPreviews.get(name);
      Bitmap bitmap=bitmapReference.get();
      if (bitmap != null) {
        return bitmap;
      }
    }
  }
  Bitmap unusedBitmap=null;
synchronized (mUnusedBitmaps) {
    while (unusedBitmap == null && mUnusedBitmaps.size() > 0) {
      Bitmap candidate=mUnusedBitmaps.remove(0).get();
      if (candidate != null && candidate.isMutable() && candidate.getWidth() == mPreviewBitmapWidth && candidate.getHeight() == mPreviewBitmapHeight) {
        unusedBitmap=candidate;
      }
    }
  }
  if (unusedBitmap == null) {
    unusedBitmap=Bitmap.createBitmap(mPreviewBitmapWidth,mPreviewBitmapHeight,Bitmap.Config.ARGB_8888);
  }
  Bitmap preview=readFromDb(name,unusedBitmap);
  if (preview != null) {
synchronized (mLoadedPreviews) {
      mLoadedPreviews.put(name,new WeakReference<Bitmap>(preview));
    }
    return preview;
  }
 else {
    final Bitmap generatedPreview=generatePreview(o,unusedBitmap);
    preview=generatedPreview;
    if (preview != unusedBitmap) {
      throw new RuntimeException("generatePreview is not recycling the bitmap " + o);
    }
synchronized (mLoadedPreviews) {
      mLoadedPreviews.put(name,new WeakReference<Bitmap>(preview));
    }
    new AsyncTask<Void,Void,Void>(){
      public Void doInBackground(      Void... args){
        writeToDb(o,generatedPreview);
        return null;
      }
    }
.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,(Void)null);
    return preview;
  }
}
