{
  if (mVelocityTracker == null) {
    mVelocityTracker=VelocityTracker.obtain();
  }
  mVelocityTracker.addMovement(ev);
  final int action=ev.getAction();
switch (action & MotionEvent.ACTION_MASK) {
case MotionEvent.ACTION_DOWN:
    if (!mScroller.isFinished()) {
      mScroller.abortAnimation();
    }
  mDownMotionX=mLastMotionX=ev.getX();
mActivePointerId=ev.getPointerId(0);
break;
case MotionEvent.ACTION_MOVE:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int pointerIndex=ev.findPointerIndex(mActivePointerId);
final float x=ev.getX(pointerIndex);
final int deltaX=(int)(mLastMotionX - x);
mLastMotionX=x;
int sx=getScrollX();
if (deltaX < 0) {
if (sx > 0) {
  scrollBy(Math.max(-sx,deltaX),0);
}
}
 else if (deltaX > 0) {
final int lastChildIndex=getChildCount() - 1;
final int availableToScroll=getChildOffset(lastChildIndex) - getRelativeChildOffset(lastChildIndex) - sx;
if (availableToScroll > 0) {
  scrollBy(Math.min(availableToScroll,deltaX),0);
}
}
 else {
awakenScrollBars();
}
}
 else if ((mTouchState == TOUCH_STATE_PREV_PAGE) || (mTouchState == TOUCH_STATE_NEXT_PAGE)) {
determineScrollingStart(ev);
}
break;
case MotionEvent.ACTION_UP:
if (mTouchState == TOUCH_STATE_SCROLLING) {
final int activePointerId=mActivePointerId;
final int pointerIndex=ev.findPointerIndex(activePointerId);
final float x=ev.getX(pointerIndex);
final VelocityTracker velocityTracker=mVelocityTracker;
velocityTracker.computeCurrentVelocity(1000,mMaximumVelocity);
int velocityX=(int)velocityTracker.getXVelocity(activePointerId);
boolean isfling=Math.abs(mDownMotionX - x) > MIN_LENGTH_FOR_FLING;
if (isfling && velocityX > SNAP_VELOCITY && mCurrentPage > 0) {
snapToPage(mCurrentPage - 1);
}
 else if (isfling && velocityX < -SNAP_VELOCITY && mCurrentPage < getChildCount() - 1) {
snapToPage(mCurrentPage + 1);
}
 else {
snapToDestination();
}
if (mVelocityTracker != null) {
mVelocityTracker.recycle();
mVelocityTracker=null;
}
}
 else if (mTouchState == TOUCH_STATE_PREV_PAGE) {
int nextPage=Math.max(0,mCurrentPage - 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
 else if (mTouchState == TOUCH_STATE_NEXT_PAGE) {
int nextPage=Math.min(getChildCount() - 1,mCurrentPage + 1);
if (nextPage != mCurrentPage) {
snapToPage(nextPage);
}
 else {
snapToDestination();
}
}
mTouchState=TOUCH_STATE_REST;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_CANCEL:
mTouchState=TOUCH_STATE_REST;
mActivePointerId=INVALID_POINTER;
break;
case MotionEvent.ACTION_POINTER_UP:
onSecondaryPointerUp(ev);
break;
}
return true;
}
