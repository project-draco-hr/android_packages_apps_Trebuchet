{
  mPVA=new ProgramVertex.MatrixAllocation(mRS);
  resize(mWidth,mHeight);
  ProgramVertex.Builder pvb=new ProgramVertex.Builder(mRS,null,null);
  pvb.setTextureMatrixEnable(true);
  mPV=pvb.create();
  mPV.setName("PV");
  mPV.bindAllocation(mPVA);
  Element.Builder eb=new Element.Builder(mRS);
  eb.add(Element.createVector(mRS,Element.DataType.FLOAT_32,2),"ImgSize");
  eb.add(Element.createVector(mRS,Element.DataType.FLOAT_32,4),"Position");
  eb.add(Element.createVector(mRS,Element.DataType.FLOAT_32,2),"BendPos");
  eb.add(Element.createVector(mRS,Element.DataType.FLOAT_32,4),"ScaleOffset");
  Element e=eb.create();
  mUniformAlloc=Allocation.createSized(mRS,e,1);
  initMesh();
  ProgramVertex.ShaderBuilder sb=new ProgramVertex.ShaderBuilder(mRS);
  String t=new String("void main() {\n" + "  float ani = UNI_Position.z;\n" + "  float bendY1 = UNI_BendPos.x;\n"+ "  float bendY2 = UNI_BendPos.y;\n"+ "  float bendAngle = 47.0 * (3.14 / 180.0);\n"+ "  float bendDistance = bendY1 * 0.4;\n"+ "  float distanceDimLevel = 0.6;\n"+ "  float bendStep = (bendAngle / bendDistance) * (bendAngle * 0.5);\n"+ "  float aDy = cos(bendAngle);\n"+ "  float aDz = sin(bendAngle);\n"+ "  float scale = (2.0 / 480.0);\n"+ "  float x = UNI_Position.x + UNI_ImgSize.x * (1.0 - ani) * (ATTRIB_position.x - 0.5);\n"+ "  float ys= UNI_Position.y + UNI_ImgSize.y * (1.0 - ani) * ATTRIB_position.y;\n"+ "  float y = 0.0;\n"+ "  float z = 0.0;\n"+ "  float lum = 1.0;\n"+ "  float cv = min(ys, bendY1 - bendDistance) - (bendY1 - bendDistance);\n"+ "  y += cv * aDy;\n"+ "  z += -cv * aDz;\n"+ "  cv = clamp(ys, bendY1 - bendDistance, bendY1) - bendY1;\n"+ "  lum += cv / bendDistance * distanceDimLevel;\n"+ "  y += cv * cos(cv * bendStep);\n"+ "  z += cv * sin(cv * bendStep);\n"+ "  cv = max(ys, bendY2 + bendDistance) - (bendY2 + bendDistance);\n"+ "  y += cv * aDy;\n"+ "  z += cv * aDz;\n"+ "  cv = clamp(ys, bendY2, bendY2 + bendDistance) - bendY2;\n"+ "  lum -= cv / bendDistance * distanceDimLevel;\n"+ "  y += cv * cos(cv * bendStep);\n"+ "  z += cv * sin(cv * bendStep);\n"+ "  y += clamp(ys, bendY1, bendY2);\n"+ "  vec4 pos;\n"+ "  pos.x = (x + UNI_ScaleOffset.z) * UNI_ScaleOffset.x;\n"+ "  pos.y = (y + UNI_ScaleOffset.w) * UNI_ScaleOffset.x;\n"+ "  pos.z = z * UNI_ScaleOffset.x;\n"+ "  pos.w = 1.0;\n"+ "  pos.x *= 1.0 + ani * 4.0;\n"+ "  pos.y *= 1.0 + ani * 4.0;\n"+ "  pos.z -= ani * 1.5;\n"+ "  lum *= 1.0 - ani;\n"+ "  gl_Position = UNI_MVP * pos;\n"+ "  varColor.rgba = vec4(lum, lum, lum, 1.0);\n"+ "  varTex0.xy = ATTRIB_position;\n"+ "  varTex0.y = 1.0 - varTex0.y;\n"+ "  varTex0.zw = vec2(0.0, 0.0);\n"+ "}\n");
  sb.setShader(t);
  sb.addConstant(mUniformAlloc.getType());
  sb.addInput(mMesh.getVertexType(0).getElement());
  mPVCurve=sb.create();
  mPVCurve.setName("PVCurve");
  mPVCurve.bindAllocation(mPVA);
  mPVCurve.bindConstants(mUniformAlloc,1);
  mRS.contextBindProgramVertex(mPV);
}
